<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Promisee的总结]]></title>
    <url>%2F2019%2F03%2F03%2FPromise%E7%9A%84%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言不知道怎么开头，因为做项目或者之前面试的时候，经常会遇到Promise的相关问题，那就做一次总结吧。文章开始前，先问几个简单的Promise的问题： Promise是什么？ Promise.then和Promise.catch 返回的是什么呢？ Promise 可以中断吗？ Promise是什么根据MDN上的定义 A Promise is an object representing the eventual completion or failure of an asynchronous operation. 翻译: Promise是一个代表了异步操作最终完成或者失败的结果对象。 什么意思呢？Promise可以用于处理异步操作，并可以根据异步的结果而进行相应的操作。 JavaScript是单线程的语言，代码自顶向下执行，一次只能执行一次任务，代码执行过程中如果遇到了异步操作，则先将异步操作挂起，先执行下面的任务，直到当前栈所有任务执行完成，开始执行异步操作相对应的回调函数。 那这跟Promise有什么关系呢？让我们来看看Promise的基本用法先 1234567891011121314var p = new Promise(function(resolve, reject) &#123; console.log(&apos;start Promise&apos;) setTimeout(function() &#123; resolve(&apos;模拟异步操作&apos;) //模拟异步操返回结果 &#125;, 1000) console.log(&apos;end Promise&apos;) &#125;).then((result) =&gt; &#123; console.log(result)&#125;)----output----start Promiseend Promise模拟异步操作 // 1000ms后 在上面操作中，我们在Promise中使用setTimeOut模拟异步操作，利用resolve得到异步返回的结果，在then中输出来。Promise传入的函数为立即执行函数，里面执行代码遇到异步时，先执行下面的代码，输出end Promise，再去执行挂起的异步事件。 Promise可以将异步执行代码和异步结果分隔开来，通过resolve或者reject获取到异步的结果，在then中执行相应的操作。 而Promise另一个好处就是支持链式调用，避免多重的嵌套回调（回调地狱），将异步操作用同步的形式展示出来，将回调地狱代码的横向延申变为纵向延申。 1234567891011121314151617181920212223242526272829303132// 以往异步请求代码ajax(url1, data1, function (data2) &#123; console.log(&apos;得到第一次请求的结果&apos;) ajax(url2, data2, function (data3) &#123; console.log(&apos;得到第二次请求的结果&apos;) ajax(url3, data3, function(data4) &#123; console.log(&apos;得到第三次请求的结果&apos;) &#125;) &#125;)&#125;)// 使用Promisefunction requestData(url, data) &#123; return new Promise(function(resolve, reject) &#123; ajax(url, data, function(data1) &#123; resolve(data) &#125;) &#125;)&#125;requestData(url1, data1) .then((data2) =&gt; &#123; console.log(&apos;第一次返回结果&apos;) return requestData(url2, data2) &#125;) .then((data3) =&gt; &#123; console.log(&apos;第二次返回结果&apos;) return requestData(url4, data4) &#125;) .catch(e =&gt; &#123; console.log(e) //输出Promise过程中的错误 &#125;) 以上，当每一次异步请求都依赖于前一次异步请求的结果时，由于Promise将执行代码和执行结果分离，利用then进行链式调用，让多次异步任务变成同步代码按照顺序执行。 下面让我们来看一下Promise的语法吧。 Promise的语法基本语法123new Promise(function (resolve, reject) &#123; /* executor */&#125;) Promise传入一个executor的函数，resolve和reject作为两个回调函数传入executor中。executor为立即执行函数，也就是在新建Promise对象时，executor已经执行了。通常在executor内部会执行一些异步任务，resolve和reject分别将Promise的状态从pending改为fulfilled（完成）或者rejected(失败)。 注意，一旦executor执行了，就无法中断里面的代码。当函数中抛出了一个错误，则Promise的状态会改为rejected，executor返回的值会被忽略。 一个Promise对象有三种状态 1.pending：初始状态 2.fulfilled：操作已完成 3.rejected：操作失败 Promise只能有两种状态转变 1.从pengding到fulfilled, 状态改变时调用resolve,将异步操作完成的结果作为参数传递出去 2.从pending到rejected， 状态改变时调用rejected，将失败信息传递出去 当状态发生改变时，Promise的then绑定的方法会被调用(不是立即执行),。 .then语法 123Promise.prototype.then(function(onFulfilled, onRejected) &#123; ...&#125;) then方法中有两个函数类型的参数，onFulfilled和onRejected。当发生Promise的状态变为fulfilled时，调用onFulfilled方法；状态变为rejected时，调用onRejected方法。这两个方法在调用时可以分别传入异步操作的完成结果或者错误信息。 调用then之后，返回的是一个新的Promise对象（跟之前的Promise无关），因此，可以继续使用then方法，实现链式调用 12345678910111213var p1 = new Promise(function(resolve, reject) &#123; console.log(1) resolve(2)&#125;).then(res =&gt; &#123; console.log(res)&#125;).then(() =&gt; &#123; console.log(3)&#125;)----output----123 借助then，让Promise在异步操作执行和异步结果（根据不同结果绑定处理方法）不存在冲突耦合。 当then返回的Promise跟then返回的值有关系，当·then·返回一个值时，那么then返回的Promise将会成为接受状态，并且将返回的值作为接受状态的回调函数的参数值。详细的可以点击这里 1234567891011121314151617181920new Promise(function (resolve, reject) &#123; console.log(1) resolve(2)&#125;).then((res) =&gt; &#123; console.log(res) return 3 // 相当于返回一个fulfiiled状态的promise，将参数3传递给resolve &#125;).then((res) =&gt; &#123; console.log(res) return new Promise((resolve, reject) =&gt; &#123; resolve(4) &#125;)&#125;).then((res) =&gt; &#123; console.log(res)&#125;)----output----1234 .catch语法 123Promise.prototype.catch(function(onRejected) &#123; ...&#125;) catch方法可以捕捉Promise的错误信息，并执行相应的handler，它跟调用.then(undefined, onRejected)相同。因此catch的结果也是返回一个Promise对象，一样支持链式调用。 在Promise中错误具有冒泡性质，一直向后传递，直到被then或者catch中的onRejected捕捉到错误信息，才会进行操作。下面让我们看一下Promise链式调用中抛出错误要注意的点吧 Promise抛出错误后，遇到onRejected才会执行 1234567891011121314151617var p2 = new Promise(function(resolve, reject) &#123; console.log(1) throw &apos;error&apos;&#125;).then(() =&gt; &#123; console.log(2)&#125;).then(() =&gt; &#123; console.log(3)&#125;).catch((e) =&gt; &#123; console.log(e)&#125;).then(() =&gt; &#123; console.log(4)&#125;)----output----1error4 当发生了错误时，Promise状态变为rejected，调用then或者catch中的onRejected，因此以上代码不会输出2和3。 另外catch返回的依旧是一个Promise（非rejected状态），所以catch后面的then正常输出。 resolve()之后后面抛出的错误会被忽略 12345678910111213141516var p = new Promise(function(resolve, reject) &#123; resolve(1) console.log(2) //会继续执行 throw &apos;test error&apos; // 或者reject(&apos;test error&apos;)&#125;).then((res) =&gt; &#123; console.log(res) //收到参数1&#125;).then(() =&gt; &#123; console.log(3)&#125;).catch((e) =&gt; &#123; console.log(e) //不会执行&#125;)----output----213 我想这跟Promise状态改变有关，调用resolve意味着Promise状态从pending转为fulfilled后，不能再从fulfilled转为rejected状态，因此会忽略后面抛出的错误。 在异步函数中抛出的错误不会被catch捕捉到 1234567891011121314151617181920212223242526new Promise(function (resolve, reject) &#123; setTimeout(function() &#123; console.log(1) throw &apos;test catch error&apos; &#125;, 1000)&#125;).catch(e =&gt; &#123; console.log(e) //不能捕捉到错误&#125;)----output----11s后报错，提示未能捕捉到错误可以用resolve作为setTimeout的处理函数解决问题new Promise(function (resolve, reject) &#123; setTimeout(resolve, 1000)&#125;).then(() =&gt; &#123; console.log(1) throw &apos;test catch error&apos;&#125;).catch(e =&gt; &#123; console.log(e) //捕捉到错误&#125;)----output----1test catch error .finally语法 1Promise.prototype.finnaly(onFinally) finnaly方法一般放在Promise链的最后，当Promise执行结束后，不管是rejected或者fulfilled状态，执行完then或者catch后，都会执行finally中指定的回调函数。 注意，由于无法直到Promise的最终状态，所以finally的回调函数中不接受任何参数。 一般应用场景是在Promise执行完毕后，要做一些处理或者清理，就可以使用到finally 12345678910var loading = truefetch(request).then(res =&gt; &#123; if (res.status) &#123; return res.json() &#125; throw &apos;Error&apos;&#125;).then(handler(json)).catch(handlerError(error)).finally(() =&gt; loading = false) .resolve语法 12Promise.resolve(value)Promise.reject(reason) resolve方法返回一个给定值的Promise对象。如果给定的值为thenable（即带有then方法），返回的Promise会“跟随”这个thenable的对象，采用它的最终状态（指fulfilledrejected/pending） 123456789101112131415var p = Promise.resolve(&#123; then: function(resolve, reject) &#123; resolve(1) &#125;&#125;)p.then(res =&gt; &#123; console.log(1)&#125;)----output----1Promise.resolve(1).then((res) =&gt; &#123;console.log(res)&#125;)----output----1 如果传入的value本身就是promise对象，则该对象作为Promise.resolve方法的返回值返回 否则返回成功状态的Promise对象，并传入给定的值。 .all语法 1Promise.all(iterable); iterable为一个可迭代对象，Array或String 如果传入一个空对象，则返回一个完成状态的Promise状态 如果传入的Promise都为完成状态或者不含一个Promise，则Promise.all返回的Promise异步地变为完成 123456789101112var promiseAll = [Promise.resolve(1), Promise.resolve(2)]var p = Promise.all(promiseAll)console.log(p)setTimeout(function()&#123; console.log(&apos;async resolved&apos;) console.log(p) // 异步&#125;, 0)----output----// Promise &#123; &lt;state&gt;: &quot;pending&quot; &#125; // the stack is now empty// Promise &#123; &lt;state&gt;: &quot;fulfilled&quot;, &lt;value&gt;: Array[2] &#125; 其他情况下，返回一个pending的Promise。这个返回的Promise会在所有的Promise都完成或者其中一个Promise失败时，异步地变为fulfilled或者rejected。 返回的Promise的结果为一个数组，包含传入的迭代对象的所有结果值（包含非Promise值） 123456789101112131415161718192021222324Promise.all([$http.get(&apos;/demo1&apos;), $http.get(&apos;/demo2&apos;), $http.get(&apos;/demo3&apos;)]).then(function(results)&#123; console.log(&apos;result 1&apos;, results[0]); console.log(&apos;result 2&apos;, results[1]); console.log(&apos;result 3&apos;, results[2]);&#125;);var p1 = 1var p2 = Promise.resolve(2)var p3 = new Promise((re, rj) =&gt; &#123; setTimeout(re, 1000, 3)&#125;)Promise.all([p1, p2, p3]).then(res =&gt; &#123; console.log(res)&#125;)----output----1000ms后输出123 Promise.all(iterable)中当所有的promise对象都成功或者任何一个Promise对象失败时，那么Promise.all就会立即变为完成或者失败状态。这个新的Promise对象在触发成功状态以后，会把一个包含iterable里所有Promise返回值的数组作为成功回调的返回值，顺序跟iterable的顺序保持一致；如果这个新的Promise对象触发了失败状态，它会把iterable里第一个触发失败的Promise对象的错误信息作为它的失败错误信息。Promise.all方法常被用于处理多个Promise对象的状态集合，同步执行多个异步请求。 .race语法 1Promise.race(iterable) Promise.race(iterable)跟all方法不一样，一旦iterable中只要有一个Promise对象达到完成或失败的状态，返回的Promise就会立刻变为fulfilled或者rejected，并获得之前那个Promise对象的返回结果或者错误原因。 12345678910111213141516171819202122232425var p1 = new Promise(function(resolve, reject) &#123; setTimeout(resolve, 500, &quot;one&quot;); &#125;);var p2 = new Promise(function(resolve, reject) &#123; setTimeout(resolve, 100, &quot;two&quot;); &#125;);Promise.race([p1, p2]).then(function(value) &#123; console.log(value); // &quot;two&quot; // 两个都完成，但 p2 更快&#125;);var p5 = new Promise(function(resolve, reject) &#123; setTimeout(resolve, 500, &quot;five&quot;); &#125;);var p6 = new Promise(function(resolve, reject) &#123; setTimeout(reject, 100, &quot;six&quot;);&#125;);Promise.race([p5, p6]).then(function(value) &#123; // 未被调用 &#125;, function(reason) &#123; console.log(reason); // &quot;six&quot; // p6 更快，所以它失败了&#125;); 跟setTimeout的区别先看看下面代码的执行结果吧 123456789101112131415161718192021console.log(&apos;script start&apos;)setTimeout(function() &#123; console.log(&apos;setTimeout&apos;)&#125;, 0)new Promise(function(resolve, reject) &#123; console.log(&apos;promise1&apos;) resolve()&#125;).then(() =&gt; &#123; console.log(&apos;promise2&apos;)&#125;)console.log(&apos;script end&apos;)---- output ---- script startpromise1script endpromise2setTimeout 以上代码中Promise的代码将立即执行，then和setTimeout都将异步执行，然而Promise和setTimeout的区别在于Promise的异步任务会插入到microtasks（微任务）中，而setTimeout的异步任务会插入到task（宏任务）。 在浏览器机制中，所有微任务会在下一个宏任务执行之前全部执行完毕。因此promise2会早于setTimeout输出。 使用场景封装ajax使用Promise进行AJAX操作 1234567891011121314151617181920212223function search(term) &#123; var url = &apos;http://example.com/search?q=&apos; + term; var xhr = new XMLHttpRequest(); var result; var p = new Promise(function (resolve, reject) &#123; xhr.open(&apos;GET&apos;, url, true); xhr.onload = function (e) &#123; if (this.status === 200) &#123; result = JSON.parse(this.responseText); resolve(result); &#125; &#125;; xhr.onerror = function (e) &#123; reject(e); &#125;; xhr.send(); &#125;); return p; //返回Promise对象&#125;search(&quot;Hello World&quot;).then(console.log, console.error); 参考MDN-Promise JavaScript-事件机制之宏任务、为任务 浏览器事件模型和回调机制 理解promise及适用场景]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[食谱]白灼虾+玉米汁]]></title>
    <url>%2F2017%2F05%2F12%2F%E9%A3%9F%E8%B0%B1-%E7%99%BD%E7%81%BC%E8%99%BE-%E7%8E%89%E7%B1%B3%E6%B1%81%2F</url>
    <content type="text"><![CDATA[前言今天是2017年的5月12日，今晚的月亮很美，美得想摘下来，想到那句“此时相望不相闻，愿逐月华流照君”，你可安好，祝你愉快。今日特别想吃虾，下午一下课就跑去附近的村子买虾回宿舍煮了，我觉得，自己做的，真的很好吃哈哈哈。顺便就买了玉米做玉米汁嘻嘻。记一下做的流程吧！ 正文白灼虾 白灼，顾名思义就是放到沸水里烫熟然后捞起来，就可以吃了！ 食材：虾，盐，姜，葱，酱油食材准备（15min）： 将虾去头去须，去脚，然后去掉虾腹部里面的黑丝，应该是虾的肠之类的东西。如果不想那么麻烦的话，也可以去须就好。 姜切片，作用是去腥，一点点姜片再切碎，待会放入到酱料中。 葱切成葱花状，作为蘸酱料的调味品。正式步骤： 做蘸酱料，将酱油和姜片放到洗净的锅中，加热煮沸 待酱油煮沸之后，放入葱花，再煮一下，差不多就用一个小碗盛起来（整个过程注意不要把酱油烧干），酱料就算完成了！很简单的呢（3min） 把锅洗净，加水，放姜片，加热煮沸（3min） 沸了之后将处理好的虾放到沸水中，可以加一点盐，同时起到去腥的作用 煮了大概三分钟之后就可以关掉，将虾捞起来，盛饭，蘸上点酱料，开始吃嘻嘻。 ps：酱料用来拌饭也很好吃哦！这道菜做起来又简单，算上食材准备也就30分钟左右。吃虾的时候，慢慢把虾拨出来，轻轻蘸点酱，轻启X唇，再轻轻咬下去，慢慢感受虾的香味还有肉感，吃上一口拌上酱油的饭，真是开心哈哈哈。 玉米汁玉米汁是之前在朋友家喝到的，那个味道一直一直记到现在，之前自己做过一次，今天又做了，好想成为了一种记忆了？？食材： 玉米（2根）、冰糖食材准备： 拨出玉米粒，一个很方便的方法，就是先将玉米对半再对半切成四块，可以叫市场大叔阿姨帮忙，然后对着空的一边将玉米粒拨出来（原谅我没配图，自己脑补哈哈哈）正式步骤： 将玉米粒放到榨汁机，加水大概没过玉米，然后榨碎 榨的过程加入冰糖，根据个人口味加，也可以待会煮玉米的时候再加冰糖 榨完之后，就放到洗净的锅里面，不用再加水了，可以用勺子把表面的沫沫给舀掉，开锅加热 等到闻到玉米煮沸的香味就可以吃了。 ps： 因为第一次喝的时候，玉米汁里面是有玉米的碎碎的，所以我做的时候也就没有过滤了，那些碎碎喝起来还可以增加口感，建议不要过滤，当然因个人口味不同。煮的时候，可以用筷子或勺子顺时针旋转搅拌，防止底部烧焦，我自己两次都有点焦了，不过那不影响口感。整个过程加上拨玉米粒，大概花了15min，蛮简单的又超好喝。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>食谱</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建个人博客]]></title>
    <url>%2F2017%2F05%2F12%2FHexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[前言终于把博客给搭建起来了，使用了Hexo + Git，确实确实很是方便。写下这篇文章，也是想记录一下自己搭建过程，同时防止以后忘记了可以查看一番： Hexo初始化 新建文章 静态文件生成+部署 Hexo主题配置（我用的是NexT） Hexo初始化Hexo使用前提，Git+Node.js！如果电脑没有的话，就需要安装好才能初始化Hexo哦。详细的话，可以参考Hexo官方文档。 安装Hexo打开控制台，使用npm安装Hexo1npm install -g hexo-cli -g–全局安装 安装完成后，在控制台输入hexo查看是否安装成功。1hexo 初始化先进入要放置博客文件夹的文件夹或者硬盘中，在控制台输入123hexo init &lt;folder&gt; //初始化博客文件夹，folder为文件夹名称cd &lt;folder&gt; //进入博客文件夹npm install //文件夹中已有package.json,使用npm安装依赖包 我们看一下博客文件夹的目录情况：12345678.├── _config.yml //网站的配置信息├── package.json //包含所有安装的各种模块├── scaffolds //模板文件夹，新建文章时，会根据模板来建立文件├── source //资源文件夹 | └── _posts //创建文章会存在此处├── themes //主题，hexo默认主题是landscape└── node_modules //node模块文件夹 网站初体验在控制台启动服务器1hexo server 出现下图情况表明服务器启动成功在本地打开http://localhost:4000/查看建好的博客网页。（Hexo默认端口为4000）如果要更改端口，在控制台输入1hexo server -p 5000 配置个人信息打开_config.yml，这个网站的配置信息 网站信息 1234567# Sitetitle: 林小胖的暖心小屋 //网站主标题subtitle: MCM_xp&apos;s blog //副标题description: 兴趣使然的小胖子 //个人描述，有助于SEOauthor: Lin JianHuang //你的名字language: zh-Hans //网站使用语言，不同主题下语言可能不同timezone: //时区，默认使用你的电脑的时区，我应该不会去哪里，就默认好了 个人域名 12345# URLurl: http://mcmPan.github.io //你的域名，这个要自己配置root: / //默认就好permalink: :year/:month/:day/:title/permalink_defaults: ps：如果网站存放在子目录中，例如 http://yoursite.com/blog，则请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。 新建文章在控制台输入如下新建文章1hexo new [layout] &lt;title&gt; 新建文章是以markdown的格式存储在source的_post中。layout默认是post，另有两种布局，page和draft。布局 | 路径—|—post | source/_postspage | sourcedraft| source/_drafts1hexo new page tags //在source中新建tags文件夹，里面有index.md。 发布草稿，将草稿从_draft中移到_post中，而后可以通过server进行发布。因为_draft文件夹默认会在发布的时候忽略掉。1hexo publish [layout] &lt;title&gt; 静态文件生成+部署当编辑好文章之后，使用Hexo生成静态文件。在控制台输出1hexo generate 使用Git部署 先要进行Git部署，安装hexo-deployer-git 1npm install hexo-deployer-git --save 在_config.yml文件中，修改参数 12345deploy: type: git //部署类型 repo: git@github.com:mcmPan/mcmPan.github.io.git //repository库地址 branch: master //分支名称 ps：1.注意Git仓库名称一定要跟你的Github账号名一致。比如Github账号名为132812,则仓库名需要是 132812.github.io。因为最终Hexo博客是放到GitHub上托管的。Github Page是Github提供的静态网站托管服务，可以用来放置我们的项目。 部署命令1hexo deploy 该条指令可以将网站部署到服务器上面。1234hexo generatehexo deploy--&gt;简写hexo g -d 部署完成之后，就可以登陆你的域名（youname.github.io）看到博客了。 部署出现问题在进行hexo g的时候遇到了一个问题，出现1Error:spawn git ENOENt 原因是Git环境变量没有设置导致的，所以对电脑环境变量进行配置就可以解决了。右键我的电脑-&gt;属性-&gt;更改设置-&gt;高级-&gt;环境变量-&gt;在系统变量或者个人用户变量中，找到变量Path-&gt;编辑，新增Git环境变量。12环境变量：C:\Program Files (x86)\Git\bin;C:\Program Files (x86)\Git\libexec\git-core//Git的安装目录 主题配置在Hexo官方网站有很多主题展示，可以选择自己喜欢的，找到其在Github上的地址，在本地博客根目录中，将其克隆下来即可。12cd your-hexo-filegit clone themes.website themes/themesname 另一种方法就是直接将主题文件整份拷贝下来放入到themes目录下。 启用主题在_config.yml中，找到theme字段，将其更改为你要使用的主题名字1theme themename 这样就可以使用了，然后自己可以参照主题的文档进行优化，将主题风格化嘻嘻。 总结我自己是使用了NexT主题的，然后参照官方文档一步一步进行配置，扩展了用户统计和阅读统计，加了腾讯404公益页面，将整个页面换成自己喜欢的暗色系（参照blog.idhyt.com的颜色自己配置的）。比较遗憾的是，还没有增加评论功能，多说快要停了，disqus被墙官网这段时间登不上去，网易云跟帖需要自己申请一个域名，想过段时间再弄，如果有想联系我的，应该也没有哈哈哈找我邮箱嘻嘻。 感谢 感谢Hexo官方 感谢NexT官方 感谢idhyt 感谢七牛 感谢Git 感谢看到的搭建流程文章]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript数组去重]]></title>
    <url>%2F2017%2F05%2F11%2FJavaScript%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%2F</url>
    <content type="text"><![CDATA[前提在做前端笔试的时候，经常会看到要写数组去重的函数，在网上查询了一番之后，总结了下面五种去重的方法。 正文方法1创建新数组，查找在新数组是否已有项，没有则将其推进新数组里面。123456789101112131415function unique(arr) &#123; var res = []; for(var i = 0, len = arr.length; i &lt; len; i++) &#123; for(var j = 0, jlen = res.length; j &lt; jlen; j++) &#123; if(res[j] === arr[i]) break; &#125; //遍历一遍新数组之后，若j等于新数组的长度，则说明没有重复项 if(j == jlen) &#123; res.push(arr[i]); &#125; &#125; return res;&#125; 方法2使用filter过滤数组，如果查找到的数组项的下标不等于当前数组项的下标，则说明该数组项前面已有一样的项了，返回false，过滤该项。12345678function unique(a) &#123; var res = a.filter(function(item, index, array) &#123; return array.indexOf(item) === index; &#125;) return res; &#125; 方法3该方法跟方法1差不多，只是将数组重复的最后一项留下来，而不是第一项。12345678910111213function unique(a) &#123; var res = []; for(var i = 0, len = a.length; i &lt; len; i++) &#123; for(var j = i + 1; j &lt; len; j++) &#123; if(a[j] === a[i]) j = ++i; //如果找到了相同的元素，i自加，进入下一个循环，同时i赋值给j。 &#125; res.push(a[i]); &#125; return res;&#125; 方法4该方法先将数组排序，然后过滤，依次查看是否跟第一项一致，一致的话则返回false，过滤掉该数组项。12345678910function unique(arr) &#123; return arr.sort().filter(function(item, index, array) &#123; return !index || array[index-1] !== item; &#125;)&#125; 方法5嘻嘻该方法使用多了一个空对象。将数组项+自身的类型（字符串）做为对象的属性存储起来，然后赋值为1，如果查找到对象中有该属性，则有重复，不将其放入到新数组中。否则，则放入到新数组中。123456789101112131415161718function unique(arr) &#123; var obj = &#123;&#125;, res = []; for(var i = 0, len = arr.length; i &lt; len; i++) &#123; var item = arr[i]; var key = typeof(item) + item; if(obj[key] !== 1) &#123; res.push(item); obj[key] = 1; &#125; &#125; return res;&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[firstTime]]></title>
    <url>%2F2017%2F05%2F04%2FfirstTime%2F</url>
    <content type="text"><![CDATA[您好，这是林小胖的暖心小屋]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>HelloWorld</tag>
      </tags>
  </entry>
</search>